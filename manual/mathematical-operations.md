# 数学的な操作と初等関数
## 算術演算子
falseは強い0として振る舞う。
```
> false * NaN
0.0

> false * Inf
0.0
```

÷は整数の割り算の商を計算する(div関数でも可)。÷は"\div(tabキー)"と打つ。%は整数の割り算の余りを計算する(rem関数でも可)。

## 論理演算子
C/C++と同じ。ショートサーキットあり。

## ビッド演算子
使うときに見るだけでよい。

## アップデート演算子
全ての二項演算子とビット演算子にはアップデート演算子(+=とか)がある。
ただし、C/C++と違い、x+=3はx = x + 3と同じなのでコピーが発生し、型が変わりうる。
```
> x = 0x01; typeof(x)
UInt8

> x *= 2; typeof(x)
Int64
```

## ベクトル化ドット演算子
全ての二項演算子に対して、配列の要素毎に計算するよう"自動的に"定義されたドット演算子がある。Matlabのドット演算子と同じ。
```
> [1, 2, 3].^3
3-element Vector{Int64}:
  1
  8
 27
```
ドット演算子は配列とスカラーを組み合わせることができる。
同じサイズの配列同士か、片方がスカラーなら配列が返され、異なるサイズでも列ベクトルと行ベクトルなら行列が返される。

ドット演算子は文法ではドットコールとして解釈される。
```
[1, 2, 3].^3 == (^).([1, 2, 3], 3)
```
ドットコールは[ブロードキャスト](https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting)演算子である。

全ての演算子をドットコールにした時、ドット演算子が一体化している(fusing)という。
```
> A = [1, 2, 3]; 2 .* A .^ 2 .+ sin.(A)
3-element Vector{Float64}:
  2.8414709848078967
  8.909297426825681
 18.14112000805987
```
全ての二項演算子にドット演算子をつけたい時、"@."マクロが便利である。
```
> A = [1, 2, 3]; @. 2A^2 + sin(A)
3-element Vector{Float64}:
  2.8414709848078967
  8.909297426825681
 18.14112000805987
 ```
この例ではAの各要素aに対して2a^2+sin(a)を1ループで計算する。
また、この例はドットコールで書くと以下のようになる。
```
(+).( (*).(2, (^).(A, 2)), (sin).(A))
```

ドット演算子はユーザーが定義した演算子にも使える。

ドット演算子と数値リテラルの組み合わせは曖昧な意味になりうる。
```
> x = 1; 1.+x #1.0 + xなのか 1 .+ xなのかわからない
ERROR: syntax: invalid syntax "1.+"; add space(s) to clarify
```
そのため、この場合は空白を入れる必要がある。

## 数値の比較
演算子はC/C++と変わらない。≠と≤、≥が追加されている。

順序は基本的には数学と変わらないが、0とNaNは注意する必要がある。
```
> 0.0 == -0.0
true

> NaN == NaN
false

> NaN != NaN
true

> NaN < NaN
false

> NaN > NaN
false
```
NaNは自身を含め全ての浮動小数点数と等しくも大きくも小さくもない。

配列にNaNがあると頭痛がするかもしれない。
```
> [1, NaN] == [1, NaN]
false
```

isequal関数は辞書で比較に使われる関数で、デフォルトでは"=="を使うのだが、浮動小数点数と"missing"の扱いが異なる。
```
> isequal(NaN, NaN)
true

> isequal([1 NaN], [1 NaN])
true

> isequal(NaN, NaN32)
true

> isequal(-0.0, 0.0)
false
```

自作タイプの同値を定義するにはisequalメソッドを追加するだけでよい。
自作同値関数を定義するなら、"isequal(x, y)ならばhash(x) == hash(y)"が真であることを保証するhashメソッドを定義するべき。

## 比較の連鎖
比較を連ねることができる。
```
> 1 < 2 ≤ 3 > 1 == 1 != 3
true
```

ドット演算子も使える。
```
> A = [1, 2, 3]; 0 .< A .< 1
3-element BitArray{1}:
 0
 0
 0
```

評価順は未定義なので、副作用を持つ表現を使わないこと。
副作用が必要なら、ショートサーキット&&を使うこと。

## 初等関数
意味がある型で初等関数が定義されている。
ドット演算子を使用可能。

## 演算子の優先順位
詳細は[src/julia-parser.scm](https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm)にて。
演算子の優先順位はBase.operator_precedence関数で確認できる。
```
> Base.operator_precedence(:+), Base.operator_precedence(:sin)
(11, 0)
```
0は有効でない演算子を表す。

演算子の結合性(変数の右につくか、左につくか)はBase.operator_associativity関数で確認できる。
```
> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)
```
有効でない演算子の結合性はnone。

数値リテラル係数はべき乗につける場合(例 2x^2)を除いて全ての二項演算子より高い優先度を持つ。

## 数値の変換
Juliaは3つの数値の変換方法があり、違いは不正確な変換の扱いである。
以下、xを型Tに変換するとする。
1. T(x) または convert(T, x)
  - Tが浮動小数点数型 ... もっとも近い表現可能な値に変換される。+∞、-∞もありうる。
  - Tが整数型 ... xがTで表現できないなら、InexactErrorを投げる。
2. x % T ... 整数xを整数型Tに2^n(nはTのビット数)を法として変換する。つまり、二進数表現でTのビット数以上のビットは捨てる。
3. 丸め関数を使う ... 表現可能な範囲からでるとInexactErrorを投げる。
```
> round(Int8, 127.4)
127
```

関数の一覧は省略。
