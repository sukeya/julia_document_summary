# 整数と浮動小数点数

- プログラム内の整数と浮動小数点数の即値を数値リテラルと呼ぶ。
```
1
1.0
```
- これらのオブジェクトとしてのメモリ内のバイナリ表現を数値プリミティブと呼ぶ。
- 型はInt8 ~ Int64、UInt8 ~ UInt64、Bool、Float16 ~ Float64がある。

## 整数
- 整数リテラルは10進数表記で表される。
```
1
1234
```
- Sys.WORD_SIZEでシステムのビット数がわかる。
```
Sys.WORD_SIZE
```
- Int、UIntはシステムのビット数桁の整数、符号なし整数。
- Int32で表せないが、Int64なら表せる整数はシステムのビット数に関わらずInt64で表す。
- 符号なし整数は"0x"を前につけた16進数で表す。アルファベットは大文字でも小文字でも可。
```
0x123
```
- 2進数リテラルは"0b"を前につけて、8進数リテラルは"0o"を前につける。16進数リテラルと同様に、2または8進数リテラルは符号なし整数を作る。
- UInt128で表せない符号なし整数を変数に代入すると、多倍長整数BigIntになる(Julia>=1.7?)。
- 符号なし整数リテラルの直前に"-"をつけると、負の整数を作る。
```
> -0x2 + 0x2
0
```
- 符号なし整数リテラルのサイズは先頭が0でないなら、そのリテラルを表すために必要な最小限のサイズ。
もし先頭が0なら、サイズはそのリテラルと同じ以上のサイズになる(つまり先頭の0はサイズの調整用)。
0は取り除かれないし、サイズを0でない桁から数えない。
```
> typeof(0x0002)
Int16
```
- 数値プリミティブ型の表現可能な最大最小値はtypemax, typeminに型名を与えるとわかる。
```
> typemax(Int8)
127
```

## オーバーフローの扱い
- Juliaでは計算機に実装されている整数の計算の特性により、合同算術を行う(mod typemax)。
```
> typemax(Int) + 1 == typemin(Int)
true
```
- オーバーフローが起きる可能性があるなら、明示的に最小値に戻っているかを確認するか、多倍長整数BigIntを使う必要がある。
```
> 10^19

> big(10)^19
10000000000000000000
```

## 除算エラー
div関数を使った整数の除算は以下の2つの例外が起きる場合がある
1. 0割り
2. 最小値を-1で割った時

どちらもDivide Errorが投げられる。余りと合同(remとmod関数)も同様。
