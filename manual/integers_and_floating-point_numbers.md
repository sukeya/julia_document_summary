# 整数と浮動小数点数

- プログラム内の整数と浮動小数点数の即値を数値リテラルと呼ぶ。
```
1
1.0
```
- これらのオブジェクトとしてのメモリ内のバイナリ表現を数値プリミティブと呼ぶ。
- 型はInt8 ~ Int64、UInt8 ~ UInt64、Bool、Float16 ~ Float64がある。

## 整数
- 整数リテラルは10進数表記で表される。
```
1
1234
```
- Sys.WORD_SIZEでシステムのビット数がわかる。
```
Sys.WORD_SIZE
```
- Int、UIntはシステムのビット数桁の整数、符号なし整数。
- Int32で表せないが、Int64なら表せる整数はシステムのビット数に関わらずInt64で表す。
- 符号なし整数は"0x"を前につけた16進数で表す。アルファベットは大文字でも小文字でも可。
```
0x123
```
- 2進数リテラルは"0b"を前につけて、8進数リテラルは"0o"を前につける。16進数リテラルと同様に、2または8進数リテラルは符号なし整数を作る。
- UInt128で表せない符号なし整数を変数に代入すると、多倍長整数BigIntになる(Julia>=1.7?)。
- 符号なし整数リテラルの直前に"-"をつけると、負の整数を作る。
```
> -0x2 + 0x2
0
```
- 符号なし整数リテラルのサイズは先頭が0でないなら、そのリテラルを表すために必要な最小限のサイズ。
もし先頭が0なら、サイズはそのリテラルと同じ以上のサイズになる(つまり先頭の0はサイズの調整用)。
0は取り除かれないし、サイズを0でない桁から数えない。
```
> typeof(0x0002)
Int16
```
- 数値プリミティブ型の表現可能な最大最小値はtypemax, typeminに型名を与えるとわかる。
```
> typemax(Int8)
127
```

### オーバーフローの扱い
- Juliaでは計算機に実装されている整数の計算の特性により、合同算術を行う(mod typemax)。
```
> typemax(Int) + 1 == typemin(Int)
true
```
- オーバーフローが起きる可能性があるなら、明示的に最小値に戻っているかを確認するか、多倍長整数BigIntを使う必要がある。
```
> 10^19
-8446744073709551616

> big(10)^19
10000000000000000000
```

### 除算エラー
div関数を使った整数の除算は以下の2つの例外が起きる場合がある
1. 0割り
2. 最小値を-1で割った時

どちらもDivide Errorが投げられる。余りと合同(remとmod関数)も同様。


## 浮動小数点数
- 浮動小数点数リテラルは普通のフォーマットで表され、必要ならE表記も使える。
```
1.0
2.5e-4
```
- 浮動小数点数リテラルはFloat64。Float32を作成するにはE表記でfを使う。
```
5.4f0
```
- Float64をFloat32に変換するにはFloat32(x)(xはFloat64)とすればよい。
- 16進数浮動小数点数リテラルも使えるが、Float64の値とされる。pの後に基数2の指数を書く。
```
> 0x1p0
1.0

> 0x1.8p3
12.0
```
- 半精度浮動小数点数(Float16)も使えるが、ソフトウェアでの実装で計算にFloat32を使う。
- sizeof関数で型と変数のバイト数を取得できる。
```
> sizeof(Float16(4.))
2
```
- アンダースコアを数字の区切りとして使える。
```
> 10_000
10000

> 0.000_000_05
5.0e-8

> 0xdead_beef
0xdeadbeef

> 0b1011_0010
0xb2
```

### 浮動小数点数のゼロ
- 浮動小数点数は2つのゼロを持つが、Juliaでは("=="の意味で)等しいとしている。
```
> 0.0 == -0.0
true
```
bitstring関数でビット列を文字列として取得できる。

### 特別な浮動小数点数の値
- Inf、-Inf、NaNがある。Float32、16では後ろにそれぞれ32、16が付く。
- NaNは"=="ではどの浮動小数点数(NaN含め)とも等しくない。
- Infの計算は基本的に数学と変わらないが、いくつか注意点がある。
```
> 1 / 0
Inf

> -1 / 0
-Inf

> 0 / 0
NaN

> Inf - Inf
NaN

> Inf / Inf
NaN

> 0 * Inf
NaN
```
- 浮動小数点数の最大値最小値はそれぞれInf、-Inf。
```
> typemax(Float64)
Inf

> typemin(Float64)
-Inf
```

### 計算機イプシロン
まず、計算機イプシロンとは、1と1より大きい最小の浮動小数点数との差である。eps関数を使うと、
- 型 ... その型での計算機イプシロンを返す。
- 値x ... xとtypeof(x)でxより大きい最小の数との差を返す。
- なし ... eps(Float64)と同じ

注意点は数が大きければ大きいほど、指数的に浮動小数点数同士の値が広がることである。
逆に、小さければ小さいほど密になっている。
nextfloat、prevfloat関数でそれぞれ与えられた値の大きいまたは小さい隣の数が得られる。
```
> nextfloat(1.25f0)
1.2500001f0

> prevfloat(1.25f0)
1.2499999f0
```

### 丸め方
デフォルトは偶数丸め(RoundNearest)。必要なら、IEEE754に書かれた丸め方に変更できる。

